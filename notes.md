$$field.evalPolyAt(field.newVectorFrom(c), BigInt(i))$$

计算得到系数为c的多项式的值，index为i，即$f_c(i)$



$$genQuotientPolynomial$$ 即为 $(f(x) - f(r)) / (x - r)$



$$G.mulScalar(srs[i], coefficients[i])$$ 里srs即为$\alpha^i$， coefficients即为$\omega^i$

affine应该类似取模操作

multi proof中使用的是 commit和poly的变换，commit应该就是$g^{poly(\alpha)}$
$e(proof, commit(zPoly)) = e(commitment - commit(iPoly), g)$
proof = (poly - ipoly) / zpoly

唯一有疑惑的地方是这里的加减好像就是乘除，可能是加法群或者乘法群的问题？

智能合约中运行的函数：
verify  
169126 169150 169150 169150 169138 169150 169150 169138 169150
commit  
    128coffs: 1636734  1636758   1636794
    64 coffs: 828052   827980    828052
evalPolyAt  31366:2  31354:127  31354:1  31750:rand
verifyMulti
    128coffs: 9145290  9145410  9145254
    64coffs:  3286179  3286287  3286143


verify new pvss:
199093 199093 199105 199093 199105 199105 199093 199093 199093
199117 199129 199129 199117 199117 199129 199117 199117 199129


第一种方案：
201994 202006 201982 201982 201994 201994 201970 201994
第二种：
246079 253398 260166 268689 266922 275457 275433 283969 273690 282225
应该是随着index从0-9不断增大，对g2上的运算有影响。由并没有消耗很多gas可以佐证，因为指数比较小的原因，可以有效减少g2上乘法带来的消耗。
index/gas
100-109: 311041 319577 319565 328101 311041 319553 319577 328101 319565
65500-65509： 457221 465734 465734 474259 440171 448696 448696 457221 448696
65500的时候还可以接受，256bit其实很大了，如果按65536来算的话，只有16bit

踩了好多坑，g2上运算的那份代码和原先这份代码的g2上的x y是完全相反的，solidity又没法print，只能一行一行注释、编译、测试、检查